using SkiaSharp;
using static QrSharp.ArtQrCode;
using static QrSharp.QrCodeGenerator;

namespace QrSharp;

public class ArtQrCode : AbstractQrCode, IDisposable
{
    /// <summary>
    ///     Defines how the background image (if set) shall be rendered.
    /// </summary>
    public enum BackgroundImageStyle
    {
        Fill,
        DataAreaOnly
    }

    /// <summary>
    ///     Defines how the quiet zones shall be rendered.
    /// </summary>
    public enum QuietZoneStyle
    {
        Dotted,
        Flat
    }

    /// <summary>
    ///     Constructor without params to be used in COM Objects connections
    /// </summary>
    public ArtQrCode()
    {
    }

    /// <summary>
    ///     Creates new ArtQrCode object
    /// </summary>
    /// <param name="data">QrCodeData generated by the QrCodeGenerator</param>
    public ArtQrCode(QrCodeData data) : base(data)
    {
    }

    /// <summary>
    ///     Renders an art-style Qr code with dots as modules. (With default settings: DarkColor=Black, LightColor=White,
    ///     Background=Transparent, QuietZone=true)
    /// </summary>
    /// <param name="pixelsPerModule">
    ///     Amount of px each dark/light module of the Qr code shall take place in the final Qr code
    ///     image
    /// </param>
    /// <returns>QrCode graphic as bitmap</returns>
    public SKBitmap GetGraphic(int pixelsPerModule)
    {
        return GetGraphic(pixelsPerModule, SKColors.Black, SKColors.White, SKColors.Transparent);
    }

    /// <summary>
    ///     Renders an art-style Qr code with dots as modules and a background image (With default settings: DarkColor=Black,
    ///     LightColor=White, Background=Transparent, QuietZone=true)
    /// </summary>
    /// <param name="backgroundImage">A bitmap object that will be used as background picture</param>
    /// <returns>QrCode graphic as bitmap</returns>
    public SKBitmap GetGraphic(SKBitmap? backgroundImage = null)
    {
        return GetGraphic(10, SKColors.Black, SKColors.White, SKColors.Transparent, backgroundImage);
    }

    /// <summary>
    ///     Renders an art-style Qr code with dots as modules and various user settings
    /// </summary>
    /// <param name="pixelsPerModule">
    ///     Amount of px each dark/light module of the Qr code shall take place in the final Qr code
    ///     image
    /// </param>
    /// <param name="darkColor">Color of the dark modules</param>
    /// <param name="lightColor">Color of the light modules</param>
    /// <param name="backgroundColor">Color of the background</param>
    /// <param name="backgroundImage">A bitmap object that will be used as background picture</param>
    /// <param name="pixelSizeFactor">
    ///     Value between 0.0 to 1.0 that defines how big the module dots are. The bigger the value,
    ///     the less round the dots will be.
    /// </param>
    /// <param name="drawQuietZones">If true a white border is drawn around the whole Qr Code</param>
    /// <param name="quietZoneRenderingStyle">Style of the quiet zones</param>
    /// <param name="backgroundImageStyle">
    ///     Style of the background image (if set). Fill=spanning complete graphic;
    ///     DataAreaOnly=Don't paint background into quiet zone
    /// </param>
    /// <param name="finderPatternImage">Optional image that should be used instead of the default finder patterns</param>
    /// <returns>QrCode graphic as bitmap</returns>
    public SKBitmap GetGraphic(int pixelsPerModule, SKColor darkColor, SKColor lightColor, SKColor backgroundColor,
        SKBitmap? backgroundImage = null, double pixelSizeFactor = 0.8,
        bool drawQuietZones = true, QuietZoneStyle quietZoneRenderingStyle = QuietZoneStyle.Dotted,
        BackgroundImageStyle backgroundImageStyle = BackgroundImageStyle.DataAreaOnly,
        SKBitmap? finderPatternImage = null)
    {
        if (pixelSizeFactor > 1)
        {
            throw new Exception("The parameter pixelSize must be between 0 and 1. (0-100%)");
        }

        var pixelSize = (int)Math.Min(pixelsPerModule, Math.Floor(pixelsPerModule / pixelSizeFactor));

        var numModules = QrCodeData.ModuleMatrix.Count - (drawQuietZones ? 0 : 8);
        var offset = drawQuietZones ? 0 : 4;
        var size = numModules * pixelsPerModule;

        var bitmap = new SKBitmap(size, size);

        using var canvas = new SKCanvas(bitmap);
        canvas.Clear(backgroundColor);

        if (backgroundImage is not null)
        {
            switch (backgroundImageStyle)
            {
                case BackgroundImageStyle.Fill:
                    canvas.DrawBitmap(backgroundImage, new SKRect(0, 0, size, size));
                    break;
                case BackgroundImageStyle.DataAreaOnly:
                {
                    var bgOffset = 4 - offset;
                    canvas.DrawBitmap(Resize(backgroundImage, size - 2 * bgOffset * pixelsPerModule),
                        0 + bgOffset * pixelsPerModule, bgOffset * pixelsPerModule);
                    break;
                }
                default:
                    throw new ArgumentOutOfRangeException(nameof(backgroundImageStyle), backgroundImageStyle, null);
            }
        }

        var darkPaint = new SKPaint { Color = darkColor, IsAntialias = true };
        var lightPaint = new SKPaint { Color = lightColor, IsAntialias = true };

        for (var x = 0; x < numModules; x += 1)
        {
            for (var y = 0; y < numModules; y += 1)
            {
                var rectangle = new SKRect(x * pixelsPerModule, y * pixelsPerModule,
                    x * pixelsPerModule + pixelsPerModule, y * pixelsPerModule + pixelsPerModule);

                var pixelIsDark = QrCodeData.ModuleMatrix[offset + y][offset + x];
                var paint = pixelIsDark ? darkPaint : lightPaint;

                if (!IsPartOfFinderPattern(x, y, numModules, offset))
                {
                    if (drawQuietZones && quietZoneRenderingStyle == QuietZoneStyle.Flat &&
                        IsPartOfQuietZone(x, y, numModules))
                    {
                        canvas.DrawRect(rectangle, paint);
                    }
                    else
                    {
                        canvas.DrawCircle(rectangle.MidX, rectangle.MidY, pixelSize / 2f, paint);
                    }
                }
                else if (finderPatternImage is null)
                {
                    canvas.DrawRect(rectangle, paint);
                }
            }
        }

        if (finderPatternImage is null)
        {
            return bitmap;
        }

        var finderPatternSize = 7 * pixelsPerModule;
        canvas.DrawBitmap(finderPatternImage, new SKRect(0, 0, finderPatternSize, finderPatternSize));
        canvas.DrawBitmap(finderPatternImage,
            new SKRect(size - finderPatternSize, 0, finderPatternSize, finderPatternSize));
        canvas.DrawBitmap(finderPatternImage,
            new SKRect(0, size - finderPatternSize, finderPatternSize, finderPatternSize));

        return bitmap;
    }


    /// <summary>
    ///     If the pixelSize is bigger than the pixelsPerModule or may end up filling the Module making a traditional Qr code.
    /// </summary>
    /// <param name="pixelsPerModule">Pixels used per module rendered</param>
    /// <param name="pixelSize">Size of the dots</param>
    /// <param name="paint">Color of the pixels</param>
    /// <returns></returns>
    private static SKBitmap MakeDotPixel(int pixelsPerModule, int pixelSize, SKPaint paint)
    {
        // draw a dot
        var bitmap = new SKBitmap(pixelSize, pixelSize);
        using (var canvas = new SKCanvas(bitmap))
        {
            canvas.DrawCircle(pixelSize / 2f, pixelSize / 2f, pixelSize / 2f, paint);
        }

        var pixelWidth = Math.Min(pixelsPerModule, pixelSize);
        var margin = Math.Max((pixelsPerModule - pixelWidth) / 2, 0);

        // center the dot in the module and crop to stay the right size.
        var cropped = new SKBitmap(pixelsPerModule, pixelsPerModule);
        using (var canvas = new SKCanvas(cropped))
        {
            canvas.DrawBitmap(bitmap, new SKRect(margin, margin, pixelWidth, pixelWidth),
                new SKRect(((float)pixelSize - pixelWidth) / 2, ((float)pixelSize - pixelWidth) / 2, pixelWidth,
                    pixelWidth));
        }

        return cropped;
    }


    /// <summary>
    ///     Checks if a given module(-position) is part of the quiet zone of a Qr code
    /// </summary>
    /// <param name="x">X position</param>
    /// <param name="y">Y position</param>
    /// <param name="numModules">Total number of modules per row</param>
    /// <returns>true, if position is part of quiet zone</returns>
    private static bool IsPartOfQuietZone(int x, int y, int numModules)
    {
        return
            x < 4 || //left 
            y < 4 || //top
            x > numModules - 5 || //right
            y > numModules - 5; //bottom                
    }


    /// <summary>
    ///     Checks if a given module(-position) is part of one of the three finder patterns of a Qr code
    /// </summary>
    /// <param name="x">X position</param>
    /// <param name="y">Y position</param>
    /// <param name="numModules">Total number of modules per row</param>
    /// <param name="offset">Offset in modules (usually depending on drawQuietZones parameter)</param>
    /// <returns>true, if position is part of any finder pattern</returns>
    private static bool IsPartOfFinderPattern(int x, int y, int numModules, int offset)
    {
        var cornerSize = 11 - offset;
        var outerLimitLow = numModules - cornerSize - 1;
        var outerLimitHigh = outerLimitLow + 8;
        var invertedOffset = 4 - offset;
        return
            (x >= invertedOffset && x < cornerSize && y >= invertedOffset &&
             y < cornerSize) || //Top-left finder pattern
            (x > outerLimitLow && x < outerLimitHigh && y >= invertedOffset &&
             y < cornerSize) || //Top-right finder pattern
            (x >= invertedOffset && x < cornerSize && y > outerLimitLow &&
             y < outerLimitHigh); //Bottom-left finder pattern
    }

    /// <summary>
    ///     Resize to a square bitmap, but maintain the aspect ratio by padding transparently.
    /// </summary>
    /// <param name="image"></param>
    /// <param name="newSize"></param>
    /// <returns>Resized image as bitmap</returns>
    private static SKBitmap Resize(SKBitmap image, int newSize)
    {
        var scale = Math.Min((float)newSize / image.Width, (float)newSize / image.Height);
        var scaledWidth = (int)(image.Width * scale);
        var scaledHeight = (int)(image.Height * scale);
        var offsetX = (newSize - scaledWidth) / 2;
        var offsetY = (newSize - scaledHeight) / 2;

        var scaledImage = image.Resize(new SKSizeI(scaledWidth, scaledHeight), SKFilterQuality.High);
        var bm = new SKBitmap(newSize, newSize);

        using var canvas = new SKCanvas(bm);
        var paint = new SKPaint
        {
            IsAntialias = true,
            FilterQuality = SKFilterQuality.High,
            BlendMode = SKBlendMode.Src
        };
        canvas.Clear(SKColors.Transparent);
        canvas.DrawBitmap(scaledImage, new SKRect(offsetX, offsetY, offsetX + scaledWidth, offsetY + scaledHeight),
            paint);

        return bm;
    }
}

public static class ArtQrCodeHelper
{
    /// <summary>
    ///     Helper function to create an ArtQrCode graphic with a single function call
    /// </summary>
    /// <param name="plainText">Text/payload to be encoded inside the Qr code</param>
    /// <param name="pixelsPerModule">
    ///     Amount of px each dark/light module of the Qr code shall take place in the final Qr code
    ///     image
    /// </param>
    /// <param name="darkColor">Color of the dark modules</param>
    /// <param name="lightColor">Color of the light modules</param>
    /// <param name="backgroundColor">Color of the background</param>
    /// <param name="eccLevel">The level of error correction data</param>
    /// <param name="forceUtf8">Shall the generator be forced to work in UTF-8 mode?</param>
    /// <param name="utf8BOM">Should the byte-order-mark be used?</param>
    /// <param name="eciMode">Which ECI mode shall be used?</param>
    /// <param name="requestedVersion">Set fixed Qr code target version.</param>
    /// <param name="backgroundImage">A bitmap object that will be used as background picture</param>
    /// <param name="pixelSizeFactor">
    ///     Value between 0.0 to 1.0 that defines how big the module dots are. The bigger the value,
    ///     the less round the dots will be.
    /// </param>
    /// <param name="drawQuietZones">If true a white border is drawn around the whole Qr Code</param>
    /// <param name="quietZoneRenderingStyle">Style of the quiet zones</param>
    /// <param name="backgroundImageStyle">
    ///     Style of the background image (if set). Fill=spanning complete graphic;
    ///     DataAreaOnly=Don't paint background into quiet zone
    /// </param>
    /// <param name="finderPatternImage">Optional image that should be used instead of the default finder patterns</param>
    /// <returns>QrCode graphic as bitmap</returns>
    public static SKBitmap GetQrCode(
        string plainText, int pixelsPerModule, SKColor darkColor, SKColor lightColor,
        SKColor backgroundColor, ECCLevel eccLevel, bool forceUtf8 = false,
        bool utf8BOM = false, EciMode eciMode = EciMode.Default, int requestedVersion = -1,
        SKBitmap? backgroundImage = null, double pixelSizeFactor = 0.8,
        bool drawQuietZones = true, QuietZoneStyle quietZoneRenderingStyle = QuietZoneStyle.Flat,
        BackgroundImageStyle backgroundImageStyle = BackgroundImageStyle.DataAreaOnly,
        SKBitmap? finderPatternImage = null)
    {
        var qrCodeData =
            CreateQrCode(plainText, eccLevel, forceUtf8, utf8BOM, eciMode, requestedVersion);
        var qrCode = new ArtQrCode(qrCodeData);

        return qrCode.GetGraphic(pixelsPerModule, darkColor, lightColor, backgroundColor, backgroundImage,
            pixelSizeFactor, drawQuietZones, quietZoneRenderingStyle, backgroundImageStyle, finderPatternImage);
    }
}